#  进程与线程

[TOC]

## 进程

严格来说，在某一瞬间，CPU只能运行一个进程。但在1秒钟期间，它可以运行多个进程，这样就产生并行的错觉。这也称为伪并行，一次来区分**多处理器系统**（该系统有两个或者多个CPU共享同一个物理内存）的真正硬件并行。

---

###  进程模型

计算机上所有课运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称**进程**。

一个进程是某种类型的一个活动，它有程序、输入、暑促以及状态。耽搁处理器可以被多个进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程提供服务。

---

###  创建进程

有4中主要事件导致进程的**创建**：

1.  系统初始化
2.  执行了正在运行的进程所谓的进程创建系统调用
3.  用户请求创建一个新进程
4.  一个批处理作业的初始化

 在Unix系统中，只有一个系统调用可以创建新进程：==fork==。这个系统调用会创建一个与调用进程相同的副本。进程创建之后，父进程和子进程各自有不同的地址空间，如果其中某个进程在其地址空间修改了一个字，这个修改对其他进程而言是不可见的。

---

###  进程的终止

以下条件引起进程终止：

1.  正常退出
2.  出错退出
3.  严重错误
4.  被其他进程杀死

---

### 进程的层次结构

在Unix中，进程和它的所有子女以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组的所有成员（它们通常是在当前窗口创建的所有的活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认操作的动作，即被该信号==杀死==。

---

###  进程的状态

每个进程有自己的程序计数器和内部状态，进程之间经常需要互相作用。

进程有三种状态：

1.  运行态
2.  就绪态
3.  阻塞态

前两种状态可以相互转换。

![](https://i.loli.net/2020/03/22/JKpvE5waTZ6yfVz.png)

---

###  进程的实现

内核中维护一个进程表。每个进程占用一个表项。该表项包含进程运行的重要信息。

---

##  线程

###  线程的使用

需要多线程的理由：

1. 简化系统设计，多线程可以共享同一地址空间和所有可用数据。
2. 线程比进程更轻量级，所以比进程更容易创建和销毁。
3. 多线程可以加速IO操作和大量计算的处理过程。
4. 在多CPU系统，可以实现真正的并行。

---

###  经典的线程模型

每个线程拥有一个程序计数器、寄存器和堆栈。

进程是资源分配的基本单位。线程是CPU分派和调度的基本单位。

在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情况下，多个线程共享同一个地址空间额其他资源。而在后一种情况，多个进程共享物理内存、磁盘、打印机等相关资源。由于线程具有进程的某些性质，所以有时候被称为**==轻量级进程==**。

| 每个进程中的内容   | 每个线程中的内容 |
| ------------------ | :--------------- |
| 地址空间           | 程序计数器       |
| 全局变量           | 寄存器           |
| 打开文件           | 堆栈             |
| 子进程             | 状态             |
| 即将发生的报警     |                  |
| 信号与信号处理程序 |                  |
| 账号信息           |                  |

线程可以处于运行、阻塞、就绪、终止的任何一个状态。

在多线程的情况下，进程通常会从当前的单个线程开始。这个线程有能力通过调用一个函数`thread_create`创建新的线程。当一个线程完成工作后，调用`thread_exit`退出。在某些线程系统中，通过调用一个过程，例如`thread_join`，一个线程可以等待一个特性的线程退出。`thread_yield`允许线程自动放弃CPU而让另一个线程运行。

---

##  在用户空间中实现线程

两种主要的方法实现线程包：在用户空间和内核中。

把线程包放在用户空间中，内核对线程包一无所知。用户级线程包可以在不支持线程的操作系统上实现。用户控件关系线程时，进程需要有专用的线程表，来跟踪该进程中的线程。

进程与线程有一个关键的差别。在线程运行完成时，`thread_yield`可以把该线程的信息保存在线程表中，保存该线程和状态都是本地过程，所以比内核调用效率要高。另一方面不需要trap，不需要上下文切换，使得线程调度非常快捷。

用户级线程可以允许每个进程有自己定制的调度算法。

用户级线程在一个线程使用系统调用阻塞后，该进程的所有线程都阻塞。

用户级线程无法被CPU调度剥夺时间片。

---

###  在内核实现线程

进行操作时需要系统调用，开销大。

###  弹出式线程

一个消息的到达导致系统创建一个处理该消息的线程，称为弹出式线程。

---

##  进程间通信

###  竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**==竞争条件==**。

###  临界区

**==互斥==**：以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。

接下来介绍几种互斥的方案。

###  忙等待互斥

####  屏蔽中断

进程在刚进入临界区就屏蔽中断，离开打开中断。用户使用可能出现崩溃。

####  锁变量

加锁，不是原子操作可能导致竞争条件。

####  严格轮换法

严格控制进程轮换进入临界区。

####  Peterson解法

####  TSL指令

使用会标TSL或XCHG指令。

####  睡眠与唤醒

**==优先级翻转==**：优先级高的进程等待优先级低的进程释放临界区。

###  信号量

down：检查信号量，如果为0则睡眠，如果大于0，则减一，进入临界区。

up：退出时，将信号量加一。

信号量的另一种用途是实现同步。

###  互斥量

如果不需要信号量的计数能力，就可以使用互斥量，进行解锁和加锁。

###  管程

高级同步原语。

任何时刻管程中只有一个活跃进程。

###  消息传递

使用消息队列

###  屏障

用来同步多进程工作，以便于进行下一步操作。

---

##  调度

![1584753880853](https://i.loli.net/2020/03/22/ocXPb7fOvDwIN9G.png)

吞吐量是系统每小时完成的作业数量。

周转时间是一个批处理作业提交开始到完成时刻的统计平均时间。

最小响应时间是发出命令到得到相应之间的时间。

###  批处理系统地调度

1. 先来先服务，按照顺序进行，比较公平，对IO密集型不友好
2. 最短作业优先，长作业得不到运行
3. 最短剩余时间优先，长作业得不到运行

###  交互式系统中的调度

1. 轮转调度，对最后的短作业不友好
2. 优先级调度
3. 多级队列，一个作业用完时间片后移到下一个队列
4. 最短进程优先
5. 保证调度，通过计算进程使用过的CPU时间获取将得到的使用时间
6. 彩票制度，不同的进程分配不同的彩票数量，随机选择彩票
7. 公平分享调度

###  实时系统中的调度

