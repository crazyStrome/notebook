[TOC]

#  运输层

运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。该层为运行在不同主机上的应用程序提供直接的通信服务起着至关重要的作用。

##  概述和运输层服务

运输层协议为运行在不同主机上的应用程序之间提供了==逻辑通道==。

<img src="https://i.loli.net/2020/03/22/ijCPRYbwfqZ6WDu.png" alt="image-20200322184625350" style="zoom:150%;" />

由上图可见，运输层协议是在端系统中而不是网络路由器中实现的。在发送方，运输层将接收到的来自发送应用进程的报文转换成运输层分组，称其为**运输层报文段**。

网络路由器仅作用于该数据报的网络层字段，即他们不检查封装在该数据报的运输层报文段的字段。

###  运输层和网络层的关系

运输层为运行在不同主机上的进程提供逻辑通信，而网络层提供了主机之间的逻辑通信。

###  因特网运输层概述

在与因特网相关的环境中，将运输层报文段称为报文段。然而，在因特网的文献中，将TCP的运输层分组称为报文段，而将UDP的运输层分组称为数据报。

因特网网络层协议有一个名字叫IP，全称是网际协议。IP为主机之间提供逻辑通信。IP的服务模型是尽力而为交付服务。这意味着IP不确保报文段的交付，不保证报文段的按序交付，更不保证报文段的数据完整性。由于这些原因，IP被称为不可靠服务。

将主机间交付扩展到进程间交付，称为运输层的多路复用和多路分解。UDP和TCP还可以通过在其报文段的首部中添加差错检测字段而提供完整性检查。

TCP提供可靠数据传输服务，拥塞控制。

##  多路复用和多路分解

多路复用和多路分解，就是讲网络层提供的主机到主机交付服务扩展到为在主机上运行的应用程序所提供的进程到进程交付服务。

进程有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。

将运输层报文段中的数据交付到正确的套接字的工作成为**==多路分解==**。从源主机的不同套接字中收集数据块，并位每个数据块封装上首部信息从而生成报文段，然后将报文传递到网络层的工作是**==多路复用==**。

运输层多路复用的要求：

1. 套接字有唯一标识符
2. 每个报文段有特殊字符来指示该报文段要交付的套接字

这些特殊字段是==源端口号==和==目的端口号==字段。0~1023范围的端口号称为==周知端口号==是受严格控制的。

一个UDP套接字是由一个包含目的IP地址和目的端口号的二元组来全面表示的。

TCP套接字是由一个四元组（源IP地址，源端口号、目的IP地址、目的端口号）来标识的。

##  无连接运输：UDP

使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有进行握手，所以说UDP是*==无连接的==*。

很多应用更适合用UDP：

1. 应用层能更好地控制要发送的数据和发送时间。
2. 无需建立连接，所以相比TCP要快速。
3. 无连接状态。TCP需要在端系统中维护连接状态，而UDP不用。
4. 分组首部开销小。TCP都有20字节的首部开销，UDP只有8字节的开销。

使用UDP的应用是可以实现可靠数据传输的，这可以在应用程序自身中建立可靠性机制来完成（例如，增加确认与重传机制）。

###  UDP报文段结构

![image-20200322192841115](https://i.loli.net/2020/03/22/icVonWNX3rQgqAh.png)

UDP首部只有4个字段，每个字段由两个字节组成。

长度字段指明了包括首部在内的UDP报文长度。

###  UDP校验和

假设要传输三个16位字，则将3个16位字依次相加，如果有加法溢出，则回卷。校验和就是求得和的反码运算结果。在接收方，全部的4个16位字（包括校验和）一起相加。如果分组无差错，则接收方的和将是1111111111111111。如果有一个比特是0，则分组出现差错。

##  可靠数据传输的原理

###  构造可靠数据传输协议

基于重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议，ARQ协议还需要另外三种协议来处理存在的比特差错：

* 差错协议。
* 接收方反馈。
* 重传。接收方收到有差错的分组时，发送方将重传该分组。

###  回退N步-滑动窗口协议

![image-20200322200425293](https://i.loli.net/2020/03/22/1irKRcDbV8kNLsj.png)

在发送方的发送缓冲区中，存在着四种报文段类型：

* 已经发送并且确认的
* 已经发送等待确认的
* 未发送但是可以等待发送的
* 未发送但是不可以发送的

该窗口中就包括了已经发送等待确认的以及未发送但是等待发送的报文段。

##  面向连接的运输：TCP

TCP提供的是全双工的服务，是点对点的。

![image-20200322200929088](https://i.loli.net/2020/03/22/eZj4HwT8GFP2O6m.png)

如上图所示，TCP将这些数据引导到该连接的==发送缓存==里，发送缓存是三次握手初期设置的缓存之一。

TCP可从缓存中取出并放入报文段中的数据量受限于==最大报文段长==（MSS）。MSS通常根据最初确定的最大链路层帧长度来设置，本地发送主机发送长度是这样的帧，即所谓==最大传输单元（maximum transmission unit，MTU）==。MSS是指报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。

TCP连接的组成包括：一台主机上的缓存、变量和与一个进程连接的套接字，以及另一个主机上的一套缓存、变量和一个进程连接的套接字。

###  TCP报文段结构

![image-20200322201538519](https://i.loli.net/2020/03/22/ACq1aEPgj2eOzsm.png)

和UDP一样，首部包括源端口号和目的端口号，它用于多路复用和多路分解来自或送至上层应用的数据。TCP也包括校验和字段。还有：

* 32比特的==序号==字段和32比特的==确认号==字段。
* 16比特的==接收窗口==字段。
* 4比特的==首部长度==字段。
* 可选与变长的==选项字段==。
* 6比特的==标志==字段。ACK用来指示确认字段中的值是有效的。RST、SYN和FIN比特用于连接建立和拆除。当PSH字段被设置时，就表示接收方应立即将数据交给上层。URG比特用来指示报文里存放着被发送方上层实体置为“紧急的数据”。

####  确认号和序号

TCP把数据看成一个无结构的但是有序的字节流。序号建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个==报文段的序号==因此是该报文段首字节的字节流编号。

TCP只确认数据流中至第一个丢失字节位置的字节，所以TCP也被称为是提供==累计确认==。

一条TCP连接的双方均可以随机地选择初始序号。这样做可以减少那些仍在网络中的两台主机之间先前已终止的连接的报文段，误以为是后来这两台主机之间新建连接所产生的有效报文段的可能性。

###  流量控制

TCP提供流量控制服务和拥塞控制。

TCP让发送方维护一个==接收窗口==的变量来提供流量控制。

###  TCP连接管理

TCP客户端向服务器发起请求的过程：

1. 客户机端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包括应用层数据，但是报文段的首部中的一个标志位被置为1。因此，这个特殊报文被称为SYN报文段。另外，客户机会选择一个起始序号（client_isn），并将其放置到该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发给服务器。
2. 一旦TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户机发送允许连接的报文段。这个允许连接的报文段也不包括应用层数据。但是在首部中，SYN比特被置为1，该TCP报文段首部的确认号字段被置为client_isn+1。最后服务器选择自己的起始序号(server_isn)，并将其放置到TCP报文段首部的序号字段中。该允许连接的报文有时也称为SYNACK报文段。
3. 在收到SYNACK报文段之后，客户机也要分配缓存和变量。客户机主机还会想服务器发送另外一个报文段，这个报文段对服务器允许连接的报文段进行了确认（客户通过将值server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经被建立，所以该SYN比特被置为0。

###  SYN洪泛攻击

在三次握手中，服务器为了响应一个SYN请求，会给该请求分配缓存和相关变量。那么如果攻击者不完成三次握手的第三步，从不同的源向服务器发送SYN请求。服务器不断为这些半开的连接分配资源，导致服务器资源迅速消耗殆尽。

可以使用SYN cookie防御：

* 当服务器收到SYN报文段时，并不会为给报文生成一个半开的连接，即分配缓存和变量。服务器会生成一个初始序列号，该序列号是SYN报文段的源和目的IP地址、端口号以及仅被服务器所知的秘密数的一个复杂函数生成的。这个初始序列号被称为“cookie”。
* 如果客户是合法的，他将返回一个ACK报文段。服务器收到ACK并进行验证。通过使用ACK报文中的相同字段和秘密数运行相同的函数，如果该结果加1和确认号相同的话，就认为是合法的，服务器建立一个全开的连接。
* 另一方面，如果客户端没有返回，服务器就不为它分配资源。

##  拥塞控制原理

###  拥塞控制方法

根据网络层是否为运输层拥塞控制提供了显示的帮助来区分网络拥塞控制算法：

* 端到端拥塞控制
* 网络辅助的拥塞控制

##  TCP拥塞控制

TCP采用的方法是让每一个发送方根据感知到的网络拥塞的程度，来限制其能向连接发送流量的速率。

TCP连接的每一端都由一个接收缓存、一个发送缓存和几个变量组成。TCP拥塞控制机制让连接的每一端都记录一个额外的变量，即==拥塞窗口==。拥塞窗口表示为CongWin，它对一个TCP发送方能向网络中发送的速率进行了限制。特别是在发送方中未被确认的数据量不会超过CongWin和RcvWindow的最小值。

发送方的发送速率大概是CongWin/RTT 字节/秒。通过调节CongWin的值，发送方就能调整它向连接中发送数据的速率。

TCP发送方的丢包事件：要么出现超时，要么收到来自接收方的3个冗余的ACK。

###  拥塞控制算法

####  加性增、乘性减

当检测到一个丢包事件，把CongWin减半，最低为一个MSS。

当网络无阻塞时，每收到一个确认号就把CongWin增加一个MSS。

TCP拥塞控制协议的线性增长阶段被称为==拥塞避免==。

####  慢启动

CongWin在一开始是一个MSS。在这个==慢启动==阶段，TCP发送方以指数级增长发送速率直到丢包发生。

####  对超时时间做出反应

TCP通过维持一个阈值来确定慢启动将结束并且拥塞避免将开始的窗口长度。阈值一开始很大，每当发生一次丢包事件，阈值就会设置为当前CongWin的一半。